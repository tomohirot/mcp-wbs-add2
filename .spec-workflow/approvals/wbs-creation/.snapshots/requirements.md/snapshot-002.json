{
  "id": "snapshot_1766895711429_ygjm9h9ze",
  "approvalId": "approval_1766895429120_yq8j8l46o",
  "approvalTitle": "WBS creation requirements document",
  "version": 2,
  "timestamp": "2025-12-28T04:21:51.429Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nWBS（Work Breakdown Structure）作成機能は、プロジェクトマネージャーの業務効率化を目的とした機能です。テンプレートURLと新規追加タスクを受け付け、両者をインテリジェントにマージしてBacklogに一括登録します。この機能により、プロジェクト立ち上げ時のタスク登録作業を大幅に削減し、テンプレートの再利用を促進します。\n\n主な価値：\n- **時間削減**: 手動タスク登録と比較して80%以上の時間削減\n- **品質向上**: テンプレート活用によるタスクの抜け漏れ防止\n- **一貫性**: 過去のプロジェクトパターンの再利用による標準化\n\n## Alignment with Product Vision\n\nこの機能は、product.mdに記載されたプロダクトビジョンと以下の点で整合します：\n\n1. **自動化ファースト原則**: テンプレート取得、データ変換、タスクマージ、Backlog登録の全プロセスを自動化\n2. **柔軟性と拡張性**: MCP経由でBacklog/Notionと連携し、将来的な外部サービス追加が容易\n3. **データの透明性**: すべての処理をメタデータとして記録し、トレーサビリティを確保\n\nビジネス目標への貢献：\n- **業務効率化**: プロジェクト立ち上げ時のWBS作成時間を80%削減（目標達成）\n- **テンプレート再利用率**: 70%以上の達成に寄与\n- **データ整合性**: Backlog登録成功率99%以上を実現\n\n## Requirements\n\n### Requirement 1: テンプレートURLからのデータ取得\n\n**User Story:** プロジェクトマネージャーとして、過去のプロジェクトのWBSテンプレートURLを指定することで、そのタスク構造を再利用したい。これにより、毎回ゼロから作成する手間を省きたい。\n\n#### Acceptance Criteria\n\n1. WHEN ユーザーがBacklogまたはNotionのURLを入力 THEN システムはURLから外部サービスを自動判定する SHALL\n2. WHEN URLがBacklogの場合 THEN システムはBacklog MCPクライアント経由でデータを取得する SHALL\n3. WHEN URLがNotionの場合 THEN システムはNotion MCPクライアント経由でデータを取得する SHALL\n4. WHEN URLから階層データを取得 THEN システムは全ファイル/ページを再帰的に辿る SHALL\n5. IF 取得したファイルがExcel形式（.xlsx）の場合 THEN システムはGoogle Document AIを使用してJSONに変換する SHALL\n6. IF 取得したファイルがテキスト形式の場合 THEN システムはMarkdown形式として処理する SHALL\n7. WHEN データ取得が完了 THEN システムは以下のメタデータを生成してFirestoreに保存する SHALL:\n   - 取得元ファイル名\n   - 親URL\n   - ファイルURL\n   - ファイル名\n   - 更新日\n   - インクリメントしたバージョン番号\n8. WHEN メタデータ保存後 THEN システムは変換後のJSON/MarkdownデータをGCSに保存する SHALL\n9. WHEN データ取得に失敗した場合 THEN システムはエラーメッセージとともに処理を中断し、Cloud Loggingに記録する SHALL\n\n### Requirement 2: 新規タスクの受付と解析\n\n**User Story:** プロジェクトマネージャーとして、ミーティングで発生した新規タスクをテキストで入力することで、テンプレートに追加したい。これにより、議事録からタスクを手動で抽出する手間を省きたい。\n\n#### Acceptance Criteria\n\n1. WHEN ユーザーが新規タスクをテキストパラメータで渡す THEN システムはテキストをMarkdown形式として受け付ける SHALL\n2. WHEN 新規タスクを解析 THEN システムは各タスクのタイトル、説明、優先度、担当者を抽出する SHALL\n3. IF 新規タスクにカテゴリ情報が含まれていない場合 THEN システムはタスクの内容からカテゴリを自動判定する SHALL\n4. WHEN カテゴリ自動判定を実行 THEN システムは以下のカテゴリから最適なものを選択する SHALL:\n   - 事前準備\n   - 要件定義\n   - 基本設計\n   - 実装\n   - テスト\n   - リリース\n   - 納品\n5. WHEN 新規タスクの解析が完了 THEN システムはタスクリストを内部形式に変換する SHALL\n\n### Requirement 3: テンプレートタスクと新規タスクのマージ\n\n**User Story:** プロジェクトマネージャーとして、テンプレートタスクと新規タスクが適切にマージされ、一つのタスクリストとして整理されることを期待する。これにより、手動でのマージ作業を省きたい。\n\n#### Acceptance Criteria\n\n1. WHEN テンプレートタスクと新規タスクの両方が準備完了 THEN システムはマージ処理を開始する SHALL\n2. WHEN 新規タスクのカテゴリが判定済み THEN システムは同じカテゴリのテンプレートタスクグループに挿入する SHALL\n3. IF 新規タスクのカテゴリに対応するテンプレートタスクがない場合 THEN システムは新しいカテゴリグループを作成する SHALL\n4. WHEN マージ後 THEN システムはタスクリストをカテゴリ順（事前準備→要件定義→...→納品）にソートする SHALL\n5. WHEN 同一カテゴリ内のタスク THEN システムは以下の順序で並べる SHALL:\n   - テンプレートタスク（元の順序を維持）\n   - 新規タスク（追加順）\n6. WHEN マージが完了 THEN システムは統合されたタスクリストを生成する SHALL\n\n### Requirement 4: Backlogへのタスク一括登録\n\n**User Story:** プロジェクトマネージャーとして、マージされたタスクがBacklogに自動的に一括登録されることを期待する。ただし、既存タスクの重複は避けたい。\n\n#### Acceptance Criteria\n\n1. WHEN タスクリストのマージが完了 THEN システムはBacklog MCPクライアント経由でプロジェクトの既存タスク一覧を取得する SHALL\n2. WHEN 既存タスク一覧を取得 THEN システムは各タスクのタイトルとキーで重複チェックを行う SHALL\n3. IF 登録予定タスクが既存タスクと重複する場合 THEN システムはそのタスクをスキップする SHALL\n4. WHEN 未登録タスクのみを抽出 THEN システムはBacklog APIに一括登録リクエストを送信する SHALL\n5. WHEN タスク登録時 THEN システムは以下の情報を含める SHALL:\n   - タイトル\n   - 説明\n   - カテゴリ（種別）\n   - 優先度\n   - 担当者（指定されている場合）\n   - カスタム属性（インプット、ゴール/アウトプット）\n6. WHEN 登録が成功 THEN システムは登録されたタスクのID、タイトル、URLをレスポンスに含める SHALL\n7. WHEN 一部のタスク登録が失敗 THEN システムは成功分と失敗分を分けて結果を返す SHALL\n8. WHEN すべての登録処理が完了 THEN システムは登録結果をGoogle Cloud Loggingに記録する SHALL\n\n### Requirement 5: マスターデータの自動設定\n\n**User Story:** プロジェクトマネージャーとして、Backlogプロジェクトに必要なマスターデータ（種別、カテゴリ、マイルストーン）が自動的に設定されることを期待する。これにより、手動設定の手間を省きたい。\n\n#### Acceptance Criteria\n\n1. WHEN WBS作成処理を開始 THEN システムは対象Backlogプロジェクトのマスターデータを取得する SHALL\n2. WHEN マスターデータを取得 THEN システムは以下の種別が存在するかチェックする SHALL:\n   - 課題\n   - リスク\n3. IF 必要な種別が存在しない場合 THEN システムは不足している種別を自動追加する SHALL\n4. WHEN カテゴリをチェック THEN システムは以下のカテゴリが存在するか確認する SHALL:\n   - 事前準備\n   - 要件定義\n   - 基本設計\n   - 実装\n   - テスト\n   - リリース\n   - 納品\n5. IF 必要なカテゴリが存在しない場合 THEN システムは不足しているカテゴリを自動追加する SHALL\n6. WHEN カスタム属性をチェック THEN システムは以下の属性が存在するか確認する SHALL:\n   - インプット（文字列型）\n   - ゴール/アウトプット（文章型）\n7. IF カスタム属性が存在しない場合 THEN システムは自動作成する SHALL\n8. WHEN マスターデータ設定が完了 THEN システムは設定結果をCloud Loggingに記録する SHALL\n\n### Requirement 6: エラーハンドリングとログ記録\n\n**User Story:** システム管理者として、処理の詳細なログと明確なエラーメッセージを確認できることを期待する。これにより、問題発生時の迅速な対応が可能になる。\n\n#### Acceptance Criteria\n\n1. WHEN 任意の処理ステップが開始 THEN システムは処理開始ログをCloud Loggingに記録する SHALL\n2. WHEN 外部API呼び出しを実行 THEN システムはリクエストとレスポンスの概要をログに記録する SHALL\n3. IF API呼び出しが失敗した場合 THEN システムはエラーレベルのログを記録し、以下を含める SHALL:\n   - エラーメッセージ\n   - HTTPステータスコード\n   - APIエンドポイント\n   - リクエストパラメータ（機密情報を除く）\n4. WHEN Document AI処理を実行 THEN システムは処理対象ファイル名と処理時間をログに記録する SHALL\n5. WHEN FirestoreまたはGCSへの保存を実行 THEN システムは保存先パスとデータサイズをログに記録する SHALL\n6. WHEN 処理が正常完了 THEN システムは以下を含む完了ログを記録する SHALL:\n   - 処理時間\n   - 登録成功タスク数\n   - スキップタスク数\n   - 生成されたメタデータID\n7. WHEN 処理全体が完了またはエラー終了 THEN システムはリクエストIDでトレース可能な構造化ログを出力する SHALL\n\n### Requirement 7: データバージョン管理\n\n**User Story:** プロジェクトマネージャーとして、同じテンプレートURLから複数回WBSを作成した場合、過去のバージョンも参照できることを期待する。これにより、変更履歴の追跡が可能になる。\n\n#### Acceptance Criteria\n\n1. WHEN 同じテンプレートURLから再度データを取得 THEN システムはFirestoreから最新バージョン番号を検索する SHALL\n2. WHEN 最新バージョンが存在する場合 THEN システムはバージョン番号をインクリメントする SHALL\n3. WHEN 新規データを保存 THEN システムは新しいバージョン番号を付与してGCSに保存する SHALL\n4. WHEN ユーザーがバージョン指定なしでデータ取得 THEN システムは最新バージョンのデータを返す SHALL\n5. WHEN ユーザーが特定バージョンを指定 THEN システムはFirestoreから該当バージョンのメタデータを検索し、GCSから対応するデータを取得する SHALL\n6. WHEN バージョン履歴を参照 THEN システムは同一親URLに紐づくすべてのバージョンをリスト表示する SHALL\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- **Single Responsibility Principle**:\n  - `wbs_service.py`: WBS作成のオーケストレーションのみ\n  - `task_merger.py`: タスクマージロジックのみ\n  - `category_detector.py`: カテゴリ判定ロジックのみ\n  - 各モジュールは単一の責務を持つ\n- **Modular Design**:\n  - `processors/`: データ変換処理を独立モジュール化\n  - `integrations/`: 外部サービス連携を独立モジュール化\n  - `storage/`: データ永続化を独立モジュール化\n- **Dependency Management**:\n  - Core層（services）は外部サービス（integrations）に直接依存しない\n  - 依存性注入（DI）パターンを使用\n  - インターフェース（Pydanticモデル）を介して疎結合を実現\n- **Clear Interfaces**:\n  - MCPリクエスト/レスポンススキーマを明確に定義\n  - サービス間のデータ受け渡しはPydanticモデルを使用\n  - 公開APIは`__all__`で明示\n\n### Performance\n- **レスポンス時間**:\n  - 通常ケース（テンプレート20タスク + 新規5タスク）: 5秒以内\n  - Document AI処理: ファイルあたり3秒以内\n  - Backlog API一括登録: 50タスクあたり2秒以内\n- **スループット**:\n  - 同時リクエスト処理: 10リクエスト/秒\n  - Cloud Functionsのオートスケーリング活用\n- **メモリ使用量**:\n  - Cloud Functions 512MB以内\n  - 大量データ処理時はストリーミング処理を検討\n- **データ取得最適化**:\n  - Firestoreクエリはインデックス活用\n  - GCSからのデータ取得は必要な範囲のみ\n\n### Security\n- **認証**:\n  - Google Cloud Service Account認証\n  - Backlog/Notion APIキーはSecret Manager管理\n- **暗号化**:\n  - GCS/Firestoreはデフォルト暗号化（AES-256）\n  - API通信はHTTPS強制\n- **アクセス制御**:\n  - Cloud FunctionsにIAMロール設定\n  - GCS/FirestoreにはService Accountの最小権限付与\n- **機密情報保護**:\n  - APIキー、トークンはログに出力しない\n  - エラーメッセージに機密情報を含めない\n\n### Reliability\n- **エラーハンドリング**:\n  - すべての外部API呼び出しにtry-exceptブロック\n  - タイムアウト設定（Backlog API: 30秒、Document AI: 60秒）\n- **リトライ機構**:\n  - 一時的なAPI障害時は3回までリトライ（指数バックオフ）\n  - Cloud Tasksによる非同期リトライキューの検討\n- **データ整合性**:\n  - Backlog登録成功率99%以上\n  - Firestore/GCS保存の原子性保証（トランザクション使用）\n- **ロギング**:\n  - すべての処理ステップをCloud Loggingに記録\n  - リクエストIDによるトレーサビリティ確保\n\n### Usability\n- **エラーメッセージ**:\n  - ユーザーに分かりやすいエラーメッセージ\n  - 「URLが無効です」「Backlog API認証に失敗しました」など具体的な指示\n- **進捗フィードバック**:\n  - 長時間処理の場合は中間ステータスを返す\n  - 「テンプレート取得中...」「タスクマージ中...」「Backlog登録中...」\n- **レスポンス形式**:\n  - 成功時: 登録されたタスクのID、タイトル、URLのリスト\n  - 失敗時: エラーコード、エラーメッセージ、対処方法\n- **ドキュメント**:\n  - API仕様書（リクエスト/レスポンス形式、エラーコード一覧）\n  - セットアップガイド（GCP環境構築、APIキー設定）\n",
  "fileStats": {
    "size": 15013,
    "lines": 242,
    "lastModified": "2025-12-28T04:17:02.825Z"
  },
  "comments": []
}